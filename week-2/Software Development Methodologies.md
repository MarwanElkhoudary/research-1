# Software Development Methodologies
- What is the traditional software development life-cycle?
- How does agile differ from traditional water methodologies?
- How does the general software development life-cycle differ from the TDD lifecycle. 


# Traditional / Waterfall software development life-cycle
![Image](https://online.husson.edu/wp-content/uploads/2016/03/627x627-SftwareDev-Feature-HUSS.jpg)
# Software Development Lifecycle (SDLC)
 A software development lifecycle is a series of steps, or phases, that provide a model for the development and lifecycle management of an application or piece of software.


# What is the traditional software development life-cycle?
# Planning:
Requirement analysis is the most fundamental part of the development process. It is performed primarily by the development team, aquiring details from customers, market research, sales teams and potential users. This helps the development team plan the basic project approach and identify potential risks. Another aspect of the planning stage is putting together a cost-benefit or potential profit analysis.
# Analysis:
The analysis of a project is when a development team determines what operations, features and functions the intended application should have. The team will create frameworks, flowcharts and wireframes to determine the required technologies to then determine the parted workflow of the project .


# Design:
In this stage, the team uses the SRS (software required specifications) to design the product architecture and a design approach is selected based on their feedback(from analysis). The internal design of the architecture should be defined in a complete, detailed manner.


# Implementation:
This stage is the start of the actual development. Developers use various programming tools like interpreters, debuggers, and compilers to generate the code, along with high-level programming languages like C, C++, Java and more. At the end of this stage, the software is put into production. 
# Testing & Integration:
This stage of the development involves bringing the separate parts of the project together into a dedicated testing environment to check for errors, bugs and other issues. Some companies don’t view testing as an official stage of the process. They view it as a subset of maintenance.
# Maintenance:
When testing is completed the product is ready for deployment and release into the marketplace. Based on feedback after release, maintenance and bug fix updates may be made while deployed into the market. The team makes software improvements or change requests as needed. The ultimate goal of the maintenance phase is to ensure that the product remains relevant and high quality.




# Agile Software Development Lifecycle vs. Traditional Waterfall
![Image](http://ekiy5aot90-flywheel.netdna-ssl.com/wp-content/uploads/2013/07/segue-blog-waterfall-vs-agile-which-is-right-development-methodology-for-your-project.png)
Agile methodology in recent years has become increasingly popular by companies worldwide for software development, while the traditional waterfall model is rapidly losing its popularity. 


The waterfall model is developing in a sequential order from begenning to end where each pre-defined phase – such as: planning, design, build, test, production, and support is worked on one at a time. 


On the other hand, Agile development methodology follows a linear sequential approach while providing the flexibility for changing project requirements, as they occur.
# Example Differences
In Waterfall development, the process is divided into different phases while Agile methodology segregates the project development lifecycle into sprints. 


Waterfall is a structured software development methodology, and often times can be quite rigid, whereas the Agile methodology is known for its flexibility. 


A waterfall model development is to be completed as one single project, with each phase appearing only once during the development. However, the Agile methodology can be considered as a collection of many different projects, which are repetions of the different phases focusing on improving the overall software quality with feedback from users or the QA team. 


When using the waterfall model you have to be clear with the development requirements beforehand as there is no scope of changing once the project starts. The Agile methodology, on the other hand, is quite flexible, and allows for changes to be made in the project development requirements even after the initial planning has been completed.


One of the major differences between Agile and Waterfall development is their individual approach towards quality and testing. In the Waterfall model, the “Testing” phase comes after the “Build” phase. In the Agile methodology, testing is typically performed concurrently with programming. 


While Waterfall methodology is an internal process which does not require the participation of customers for user experience feedback, the Agile development approach focuses on the participation of customers throughout the development phase.
# Conclusion: Which Method to Use
The Waterfall model is best suited for projects which have clearly defined requirements in which change is not expected at all. Agile development supports a process in which the requirements are expected to change and evolve. Thus, if you are planning to develop a software that would require frequent overhauls and has to keep up with the technology landscape and customer requirements, Agile is the best approach to follow. 




# How does the general software development life-cycle differ from the TDD lifecycle


![Image](https://hiddeninplainsight.co.uk/wp-content/uploads/2015/03/Standard-TDD-Cycle.png)
Test-driven development (TDD) is a software development process that relies on the repetition of a very short development cycle: first the developer writes an (initially failing) automated test case that defines a desired improvement or new function, then produces the minimum amount of code to pass that test, and finally refactors the new code to acceptable standards.


# TDD Cycle:
Add a test
Run all tests and see if the new one fails
Write some code
Run tests
Refactor code
Repeat






